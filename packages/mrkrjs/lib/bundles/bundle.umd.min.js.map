{"version":3,"file":"bundle.umd.min.js","sources":["../../src/Mrkr.ts"],"sourcesContent":["type OffsetProps = {\n  startOffset?: number;\n  endOffset?: number;\n};\n\ntype DataProps = OffsetProps & {\n  text: string;\n  nodes: Text[];\n};\n\n// Type guard for Text nodes\nfunction isTextNode(node: Node): node is Text {\n  return (node as Text).nodeType === 3;\n}\n\n// Type guard for offset\nfunction isValidOffset(offset?: OffsetProps): offset is { startOffset: number; endOffset: number } {\n  return !!(offset && typeof offset.startOffset === 'number' && typeof offset.endOffset === 'number');\n}\n\n/**\n * Gets an array of text nodes under the passed node\n *\n * @param {HTMLElement} node\n * @returns {[HTMLElement]} - array of text nodes\n */\nconst textNodesUnder = (node: any): Text[] => {\n  let all: Text[] = [];\n\n  // eslint-disable-next-line no-param-reassign\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    if (isTextNode(node)) all.push(node);\n    else all = all.concat(textNodesUnder(node));\n  }\n  return all;\n};\n\ninterface Props {\n  minimum?: number;\n  maximum?: number;\n  overlap?: boolean;\n  selectionEnabled?: boolean;\n  onSelection?: (e: PointerEvent, data: DataProps[]) => void;\n}\n\ninterface Range {\n  startContainer: ChildNode;\n  endContainer: ChildNode;\n  startOffset: number;\n  endOffset: number;\n}\n\nexport default class Mrkr {\n  element: HTMLElement;\n\n  highlightClass: string;\n\n  maximum?: number;\n\n  minimum?: number;\n\n  overlap?: boolean;\n\n  onSelection?: (e: PointerEvent, data: DataProps[]) => void;\n\n  private selectionEnabled: boolean;\n\n  constructor(element: HTMLElement, className: string, props: Props = {}) {\n    const { onSelection, maximum = undefined, minimum = undefined, overlap = true, selectionEnabled = true } = props;\n\n    // Make sure element exists\n    if (!element) throw new Error('Element is required.');\n    // Make sure className\n    if (!className) throw new Error('Class name is required.');\n\n    this.element = element;\n    this.highlightClass = className;\n    this.selectionEnabled = selectionEnabled;\n    this.maximum = maximum;\n    this.minimum = minimum;\n    this.overlap = overlap;\n    this.onSelection = onSelection;\n\n    this.handlePointerUp = this.handlePointerUp.bind(this);\n\n    this.setElement(element);\n  }\n\n  /**\n   * Callback run on pointerup\n   *\n   * @private\n   * @param {PointerEvent} event\n   * @memberof Mrkr\n   */\n  private handlePointerUp(event: PointerEvent) {\n    if (this.selectionEnabled) {\n      const results = this.highlight();\n\n      if (this.onSelection) this.onSelection(event, results);\n    }\n  }\n\n  /**\n   * Gets all nodes that have the current className\n   *\n   * @private\n   * @returns {HTMLElement[]}\n   * @memberof Mrkr\n   */\n  private getHighlightedNodes(className?: string): HTMLElement[] {\n    if (!this.element) return [];\n\n    return Array.from(this.element.querySelectorAll(`.${className || this.highlightClass}`));\n  }\n\n  /**\n   * Creates a set of highlighted and non-highlighted nodes to replace the passed text content\n   *\n   * @private\n   * @param {(string | null)} [text='']\n   * @param {number} startOffset\n   * @param {number} endOffset\n   * @returns {ChildNode[]}\n   * @memberof Mrkr\n   */\n  private highlightNode(text: string | null = '', startOffset: number, endOffset: number): ChildNode[] {\n    if (!text) return [];\n\n    const highlightedText = text.substring(startOffset, endOffset);\n\n    if (highlightedText.length > 0) {\n      const highlightedSpanNode = document.createElement('SPAN');\n      highlightedSpanNode.classList.add(this.highlightClass);\n\n      const startTextNode = document.createTextNode(text.substring(0, startOffset));\n      const highlightedTextNode = document.createTextNode(highlightedText);\n      const endTextNode = document.createTextNode(text.substring(endOffset));\n\n      highlightedSpanNode.appendChild(highlightedTextNode);\n\n      const newNodes = [];\n      if (startTextNode.textContent) newNodes.push(startTextNode);\n      newNodes.push(highlightedSpanNode);\n      if (endTextNode.textContent) newNodes.push(endTextNode);\n\n      return newNodes;\n    }\n\n    return [document.createTextNode(text)];\n  }\n\n  /**\n   * Converts relative range offset data to absolute offsets\n   *\n   * @private\n   * @memberof Mrkr\n   */\n  private getAbsoluteOffsets = (\n    startContainer: Text,\n    startOffset: number,\n    endContainer: Text,\n    endOffset: number,\n  ): OffsetProps => {\n    const textNodes = textNodesUnder(this.element);\n    let currentIndex = 0;\n    let absoluteStartOffset;\n    let absoluteEndOffset;\n\n    textNodes.some((textNode) => {\n      if (!textNode?.textContent) return false;\n\n      if (textNode === startContainer) {\n        absoluteStartOffset = currentIndex + startOffset;\n      }\n\n      if (textNode === endContainer) {\n        absoluteEndOffset = currentIndex + endOffset;\n        return true;\n      }\n\n      currentIndex += textNode.textContent.length;\n      return false;\n    });\n\n    if (absoluteStartOffset && absoluteEndOffset) {\n      return { startOffset: absoluteStartOffset, endOffset: absoluteEndOffset };\n    }\n\n    return {};\n  };\n\n  /**\n   * Adds the event listener for pointerup\n   *\n   * @memberof Mrkr\n   */\n  private register(): void {\n    this.element.addEventListener('pointerup', this.handlePointerUp);\n  }\n\n  /**\n   * Removes the event listener for pointerup\n   *\n   * @memberof Mrkr\n   */\n  private unregister(): void {\n    this.element.removeEventListener('pointerup', this.handlePointerUp);\n  }\n\n  /**\n   * Sets the current classname\n   *\n   * @param {string} className\n   * @memberof Mrkr\n   */\n  setClassName(className: string): void {\n    this.highlightClass = className;\n  }\n\n  /**\n   * Searches the container element for any highlighted nodes\n   * according to the current className\n   *\n   * @param {string} [className] - optional classname, otherwise will check for this.highlightClass\n   * @returns {DataProps[]}\n   * @memberof Mrkr\n   */\n  getData(className?: string): DataProps[] {\n    if (!this.element) return [];\n\n    const textNodes = textNodesUnder(this.element);\n    const highlightedTextNodes = this.getHighlightedNodes(className).reduce(\n      (arr: Text[], current) => [...arr, ...textNodesUnder(current)],\n      [],\n    );\n\n    let currentIndex = 0;\n\n    let startFound = false;\n\n    const data: DataProps[] = [];\n\n    textNodes.some((textNode, i) => {\n      if (!textNode.textContent) return false;\n\n      const highlightedTextNode = highlightedTextNodes.find((node) => node === textNode);\n\n      if (highlightedTextNode) {\n        if (!startFound) {\n          data.push({\n            startOffset: currentIndex,\n            text: textNode.textContent,\n            nodes: [highlightedTextNode],\n          });\n\n          startFound = true;\n        } else {\n          data[data.length - 1].text += textNode.textContent;\n          data[data.length - 1].nodes.push(highlightedTextNode);\n        }\n\n        // If this node is also the last node\n        if (i === textNodes.length - 1) {\n          data[data.length - 1].endOffset = currentIndex + textNode.textContent.length;\n        }\n      } else if (startFound) {\n        data[data.length - 1].endOffset = currentIndex;\n        startFound = false;\n      }\n\n      currentIndex += textNode.textContent.length;\n\n      return false;\n    });\n\n    return data;\n  }\n\n  /**\n   * Sets the current container element\n   *\n   * @param {HTMLElement} element\n   * @memberof Mrkr\n   */\n  setElement(element: HTMLElement): void {\n    this.unregister();\n    this.element = element;\n    this.register();\n  }\n\n  /**\n   * Clears all or part of the highlighted text blocks\n   *\n   * @param {OffsetProps[]} [offsetTargets] - optional array of offsets to target and remove\n   * @returns {void}\n   * @memberof Mrkr\n   */\n  clear(offsetTargets?: OffsetProps[]): void {\n    if (!this.element) return;\n\n    // Guard against bad offset inputs\n    const offsets = offsetTargets?.filter((o) => isValidOffset(o));\n\n    const highlightedNodes = this.getHighlightedNodes();\n    const textNodes = textNodesUnder(this.element);\n\n    // If offsets array not included, clear all\n    if (!offsets) {\n      highlightedNodes.forEach((highlightedNode) => {\n        highlightedNode.replaceWith(...Array.from(highlightedNode.childNodes));\n      });\n    } else {\n      // Clear all highlighted text that falls between the offsets in the passed offsets array\n      let currentIndex = 0;\n\n      // Clear any text nodes that fall inside any of the offset ranges passed\n      textNodes.some((textNode) => {\n        if (\n          offsets.find(\n            (offset) => isValidOffset(offset) && currentIndex >= offset.startOffset && currentIndex <= offset.endOffset,\n          )\n        ) {\n          const highlightedNode = highlightedNodes.find(\n            (node) => !!Array.from(node.childNodes).find((n) => n === textNode),\n          );\n          if (highlightedNode) {\n            highlightedNode.replaceWith(...Array.from(highlightedNode.childNodes));\n          }\n        }\n\n        // Can stop searching\n        const ends = offsets.map((offset) => offset.endOffset).filter((n) => typeof n === 'number') as number[];\n        if (currentIndex > Math.max(...ends)) {\n          return true;\n        }\n\n        currentIndex += textNode.textContent?.length || 0;\n        return false;\n      });\n    }\n  }\n\n  highlight(): DataProps[] {\n    const selection = window.getSelection();\n    const results: DataProps[] = [];\n\n    // If there's no selection object\n    if (!selection) return results;\n\n    // Container element must be defined\n    if (!this.element) {\n      console.error(new Error('Container element not defined for highlighter.'));\n      return results;\n    }\n\n    const range = selection.getRangeAt(0);\n\n    const { startContainer, endContainer } = range as unknown as Range;\n\n    // Ensure that results are Text nodes\n    if (isTextNode(startContainer) && isTextNode(endContainer)) {\n      const startTextNode = startContainer;\n      const endTextNode = endContainer;\n\n      // If no content's actually been selected\n      if (startTextNode === endTextNode && range.endOffset === range.startOffset) return results;\n\n      // Convert to absolute offsets in the element\n      const offsets = this.getAbsoluteOffsets(startContainer, range.startOffset, endContainer, range.endOffset);\n\n      // Remove native selection\n      selection.removeAllRanges();\n\n      if (offsets.startOffset && offsets.endOffset) {\n        const length = offsets.endOffset - offsets.startOffset;\n\n        // Check for minimum / maximum\n        const { startOffset, endOffset } = offsets;\n        if ((this.minimum && !(length >= this.minimum)) || (this.maximum && !(length <= this.maximum))) {\n          return results;\n        }\n\n        // Check for overlap\n        if (!this.overlap) {\n          const highlights = this.getData();\n          if (\n            highlights.some(\n              (highlight) =>\n                highlight.startOffset &&\n                highlight.endOffset &&\n                ((startOffset > highlight.startOffset && startOffset < highlight.endOffset) ||\n                  (endOffset > highlight.startOffset && endOffset < highlight.endOffset)),\n            )\n          ) {\n            return results;\n          }\n        }\n      }\n\n      if (isValidOffset(offsets)) {\n        this.highlightRange(offsets.startOffset, offsets.endOffset);\n      }\n\n      return this.getData();\n    }\n\n    return results;\n  }\n\n  /**\n   * Highlights a range of text determined by start and end offsets\n   *\n   * @param {number} startOffset - absolute offset in the element container\n   * @param {number} endOffset - absolute offset in the element container\n   * @returns {DataProps[]}\n   * @memberof Mrkr\n   */\n  highlightRange(startOffset: number, endOffset: number): DataProps[] {\n    const results: DataProps[] = [];\n\n    if (!this.element) {\n      console.error(new Error('Container element not defined for highlighter.'));\n      return results;\n    }\n\n    const textNodes = textNodesUnder(this.element);\n\n    let currentIndex = 0;\n    let startFound = false;\n\n    textNodes.some((textNode) => {\n      if (!textNode.textContent) return false;\n\n      const newCurrentIndex = currentIndex + textNode.textContent.length;\n      if (startOffset >= currentIndex && startOffset < newCurrentIndex) {\n        const newNodes = this.highlightNode(textNode.textContent, startOffset - currentIndex, endOffset - currentIndex);\n        textNode.replaceWith(...newNodes);\n\n        // Start collecting text nodes in between\n        startFound = true;\n      }\n\n      if (endOffset >= currentIndex && endOffset < newCurrentIndex) {\n        const newNodes = this.highlightNode(textNode.textContent, 0, endOffset - currentIndex);\n        textNode.replaceWith(...newNodes);\n\n        // End the loop\n        return true;\n      }\n      if (startFound) {\n        const newNodes = this.highlightNode(textNode.textContent, 0, textNode.textContent.length);\n        textNode.replaceWith(...newNodes);\n      }\n\n      currentIndex = newCurrentIndex;\n      return false;\n    });\n\n    return this.getData();\n  }\n\n  getSelectionEnabled(): boolean {\n    return this.selectionEnabled;\n  }\n\n  toggleSelection(isEnabled: boolean): void {\n    this.selectionEnabled = typeof isEnabled === 'undefined' ? !this.selectionEnabled : isEnabled;\n  }\n\n  enableSelection(): void {\n    this.selectionEnabled = true;\n  }\n\n  disableSelection(): void {\n    this.selectionEnabled = false;\n  }\n}\n"],"names":["isTextNode","node","nodeType","isValidOffset","offset","startOffset","endOffset","textNodesUnder","all","firstChild","nextSibling","push","concat","Mrkr","element","className","_this","this","props","_classCallCheck","_defineProperty","startContainer","endContainer","absoluteStartOffset","absoluteEndOffset","textNodes","currentIndex","some","textNode","textContent","length","onSelection","maximum","undefined","_props$maximum","minimum","_props$minimum","overlap","_props$overlap","selectionEnabled","_props$selectionEnabl","Error","highlightClass","handlePointerUp","bind","setElement","value","event","results","highlight","Array","from","querySelectorAll","text","arguments","highlightedText","substring","highlightedSpanNode","document","createElement","classList","add","startTextNode","createTextNode","highlightedTextNode","endTextNode","appendChild","newNodes","addEventListener","removeEventListener","highlightedTextNodes","getHighlightedNodes","reduce","arr","current","_toConsumableArray","startFound","data","i","find","nodes","unregister","register","offsetTargets","offsets","filter","o","highlightedNodes","_textNode$textContent","highlightedNode","childNodes","n","replaceWith","apply","ends","map","Math","max","forEach","selection","window","getSelection","console","error","range","getRangeAt","_ref","getAbsoluteOffsets","removeAllRanges","getData","highlightRange","_this2","newCurrentIndex","highlightNode","isEnabled"],"mappings":"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"}