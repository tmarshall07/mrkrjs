{"version":3,"sources":["../../src/Mrkr.ts"],"names":["isTextNode","node","nodeType","isValidOffset","offset","startOffset","endOffset","textNodesUnder","all","firstChild","nextSibling","push","concat","Mrkr","constructor","element","className","props","onSelection","maximum","undefined","minimum","overlap","selectionEnabled","Error","highlightClass","handlePointerUp","bind","setElement","event","results","highlight","getHighlightedNodes","Array","from","querySelectorAll","highlightNode","text","highlightedText","substring","length","highlightedSpanNode","document","createElement","classList","add","startTextNode","createTextNode","highlightedTextNode","endTextNode","appendChild","newNodes","textContent","getAbsoluteOffsets","startContainer","endContainer","textNodes","currentIndex","absoluteStartOffset","absoluteEndOffset","some","textNode","register","addEventListener","unregister","removeEventListener","setClassName","getData","highlightedTextNodes","reduce","arr","current","startFound","data","i","find","nodes","clear","offsetTargets","offsets","filter","o","highlightedNodes","forEach","highlightedNode","replaceWith","childNodes","n","ends","map","Math","max","selection","window","getSelection","console","error","range","getRangeAt","removeAllRanges","highlights","highlightRange","newCurrentIndex","getSelectionEnabled","toggleSelection","isEnabled","enableSelection","disableSelection"],"mappings":"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","sourcesContent":["type OffsetProps = {\n  startOffset?: number;\n  endOffset?: number;\n};\n\ntype DataProps = OffsetProps & {\n  text: string;\n  nodes: Text[];\n};\n\n// Type guard for Text nodes\nfunction isTextNode(node: Node): node is Text {\n  return (node as Text).nodeType === 3;\n}\n\n// Type guard for offset\nfunction isValidOffset(offset?: OffsetProps): offset is { startOffset: number; endOffset: number } {\n  return !!(offset && typeof offset.startOffset === 'number' && typeof offset.endOffset === 'number');\n}\n\n/**\n * Gets an array of text nodes under the passed node\n *\n * @param {HTMLElement} node\n * @returns {[HTMLElement]} - array of text nodes\n */\nconst textNodesUnder = (node: any): Text[] => {\n  let all: Text[] = [];\n\n  // eslint-disable-next-line no-param-reassign\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    if (isTextNode(node)) all.push(node);\n    else all = all.concat(textNodesUnder(node));\n  }\n  return all;\n};\n\ninterface Props {\n  minimum?: number;\n  maximum?: number;\n  overlap?: boolean;\n  selectionEnabled?: boolean;\n  onSelection?: (e: PointerEvent, data: DataProps[]) => void;\n}\n\ninterface Range {\n  startContainer: ChildNode;\n  endContainer: ChildNode;\n  startOffset: number;\n  endOffset: number;\n}\n\nexport default class Mrkr {\n  element: HTMLElement;\n\n  highlightClass: string;\n\n  maximum?: number;\n\n  minimum?: number;\n\n  overlap?: boolean;\n\n  onSelection?: (e: PointerEvent, data: DataProps[]) => void;\n\n  private selectionEnabled: boolean;\n\n  constructor(element: HTMLElement, className: string, props: Props = {}) {\n    const { onSelection, maximum = undefined, minimum = undefined, overlap = true, selectionEnabled = true } = props;\n\n    // Make sure element exists\n    if (!element) throw new Error('Element is required.');\n    // Make sure className\n    if (!className) throw new Error('Class name is required.');\n\n    this.element = element;\n    this.highlightClass = className;\n    this.selectionEnabled = selectionEnabled;\n    this.maximum = maximum;\n    this.minimum = minimum;\n    this.overlap = overlap;\n    this.onSelection = onSelection;\n\n    this.handlePointerUp = this.handlePointerUp.bind(this);\n\n    this.setElement(element);\n  }\n\n  /**\n   * Callback run on pointerup\n   *\n   * @private\n   * @param {PointerEvent} event\n   * @memberof Mrkr\n   */\n  private handlePointerUp(event: PointerEvent) {\n    if (this.selectionEnabled) {\n      const results = this.highlight();\n\n      if (this.onSelection) this.onSelection(event, results);\n    }\n  }\n\n  /**\n   * Gets all nodes that have the current className\n   *\n   * @private\n   * @returns {HTMLElement[]}\n   * @memberof Mrkr\n   */\n  private getHighlightedNodes(className?: string): HTMLElement[] {\n    if (!this.element) return [];\n\n    return Array.from(this.element.querySelectorAll(`.${className || this.highlightClass}`));\n  }\n\n  /**\n   * Creates a set of highlighted and non-highlighted nodes to replace the passed text content\n   *\n   * @private\n   * @param {(string | null)} [text='']\n   * @param {number} startOffset\n   * @param {number} endOffset\n   * @returns {ChildNode[]}\n   * @memberof Mrkr\n   */\n  private highlightNode(text: string | null = '', startOffset: number, endOffset: number): ChildNode[] {\n    if (!text) return [];\n\n    const highlightedText = text.substring(startOffset, endOffset);\n\n    if (highlightedText.length > 0) {\n      const highlightedSpanNode = document.createElement('SPAN');\n      highlightedSpanNode.classList.add(this.highlightClass);\n\n      const startTextNode = document.createTextNode(text.substring(0, startOffset));\n      const highlightedTextNode = document.createTextNode(highlightedText);\n      const endTextNode = document.createTextNode(text.substring(endOffset));\n\n      highlightedSpanNode.appendChild(highlightedTextNode);\n\n      const newNodes = [];\n      if (startTextNode.textContent) newNodes.push(startTextNode);\n      newNodes.push(highlightedSpanNode);\n      if (endTextNode.textContent) newNodes.push(endTextNode);\n\n      return newNodes;\n    }\n\n    return [document.createTextNode(text)];\n  }\n\n  /**\n   * Converts relative range offset data to absolute offsets\n   *\n   * @private\n   * @memberof Mrkr\n   */\n  private getAbsoluteOffsets = (\n    startContainer: Text,\n    startOffset: number,\n    endContainer: Text,\n    endOffset: number,\n  ): OffsetProps => {\n    const textNodes = textNodesUnder(this.element);\n    let currentIndex = 0;\n    let absoluteStartOffset;\n    let absoluteEndOffset;\n\n    textNodes.some((textNode) => {\n      if (!textNode?.textContent) return false;\n\n      if (textNode === startContainer) {\n        absoluteStartOffset = currentIndex + startOffset;\n      }\n\n      if (textNode === endContainer) {\n        absoluteEndOffset = currentIndex + endOffset;\n        return true;\n      }\n\n      currentIndex += textNode.textContent.length;\n      return false;\n    });\n\n    if (absoluteStartOffset !== undefined && absoluteEndOffset) {\n      return { startOffset: absoluteStartOffset, endOffset: absoluteEndOffset };\n    }\n\n    return {};\n  };\n\n  /**\n   * Adds the event listener for pointerup\n   *\n   * @memberof Mrkr\n   */\n  private register(): void {\n    this.element.addEventListener('pointerup', this.handlePointerUp);\n  }\n\n  /**\n   * Removes the event listener for pointerup\n   *\n   * @memberof Mrkr\n   */\n  private unregister(): void {\n    this.element.removeEventListener('pointerup', this.handlePointerUp);\n  }\n\n  /**\n   * Sets the current classname\n   *\n   * @param {string} className\n   * @memberof Mrkr\n   */\n  setClassName(className: string): void {\n    this.highlightClass = className;\n  }\n\n  /**\n   * Searches the container element for any highlighted nodes\n   * according to the current className\n   *\n   * @param {string} [className] - optional classname, otherwise will check for this.highlightClass\n   * @returns {DataProps[]}\n   * @memberof Mrkr\n   */\n  getData(className?: string): DataProps[] {\n    if (!this.element) return [];\n\n    const textNodes = textNodesUnder(this.element);\n    const highlightedTextNodes = this.getHighlightedNodes(className).reduce(\n      (arr: Text[], current) => [...arr, ...textNodesUnder(current)],\n      [],\n    );\n\n    let currentIndex = 0;\n\n    let startFound = false;\n\n    const data: DataProps[] = [];\n\n    textNodes.some((textNode, i) => {\n      if (!textNode.textContent) return false;\n\n      const highlightedTextNode = highlightedTextNodes.find((node) => node === textNode);\n\n      if (highlightedTextNode) {\n        if (!startFound) {\n          data.push({\n            startOffset: currentIndex,\n            text: textNode.textContent,\n            nodes: [highlightedTextNode],\n          });\n\n          startFound = true;\n        } else {\n          data[data.length - 1].text += textNode.textContent;\n          data[data.length - 1].nodes.push(highlightedTextNode);\n        }\n\n        // If this node is also the last node\n        if (i === textNodes.length - 1) {\n          data[data.length - 1].endOffset = currentIndex + textNode.textContent.length;\n        }\n      } else if (startFound) {\n        data[data.length - 1].endOffset = currentIndex;\n        startFound = false;\n      }\n\n      currentIndex += textNode.textContent.length;\n\n      return false;\n    });\n\n    return data;\n  }\n\n  /**\n   * Sets the current container element\n   *\n   * @param {HTMLElement} element\n   * @memberof Mrkr\n   */\n  setElement(element: HTMLElement): void {\n    this.unregister();\n    this.element = element;\n    this.register();\n  }\n\n  /**\n   * Clears all or part of the highlighted text blocks\n   *\n   * @param {OffsetProps[]} [offsetTargets] - optional array of offsets to target and remove\n   * @returns {void}\n   * @memberof Mrkr\n   */\n  clear(offsetTargets?: OffsetProps[]): void {\n    if (!this.element) return;\n\n    // Guard against bad offset inputs\n    const offsets = offsetTargets?.filter((o) => isValidOffset(o));\n\n    const highlightedNodes = this.getHighlightedNodes();\n    const textNodes = textNodesUnder(this.element);\n\n    // If offsets array not included, clear all\n    if (!offsets) {\n      highlightedNodes.forEach((highlightedNode) => {\n        highlightedNode.replaceWith(...Array.from(highlightedNode.childNodes));\n      });\n    } else {\n      // Clear all highlighted text that falls between the offsets in the passed offsets array\n      let currentIndex = 0;\n\n      // Clear any text nodes that fall inside any of the offset ranges passed\n      textNodes.some((textNode) => {\n        if (\n          offsets.find(\n            (offset) => isValidOffset(offset) && currentIndex >= offset.startOffset && currentIndex <= offset.endOffset,\n          )\n        ) {\n          const highlightedNode = highlightedNodes.find(\n            (node) => !!Array.from(node.childNodes).find((n) => n === textNode),\n          );\n          if (highlightedNode) {\n            highlightedNode.replaceWith(...Array.from(highlightedNode.childNodes));\n          }\n        }\n\n        // Can stop searching\n        const ends = offsets.map((offset) => offset.endOffset).filter((n) => typeof n === 'number') as number[];\n        if (currentIndex > Math.max(...ends)) {\n          return true;\n        }\n\n        currentIndex += textNode.textContent?.length || 0;\n        return false;\n      });\n    }\n  }\n\n  highlight(): DataProps[] {\n    const selection = window.getSelection();\n    const results: DataProps[] = [];\n\n    // If there's no selection object\n    if (!selection) return results;\n\n    // Container element must be defined\n    if (!this.element) {\n      console.error(new Error('Container element not defined for highlighter.'));\n      return results;\n    }\n\n    const range = selection.getRangeAt(0);\n\n    const { startContainer, endContainer } = range as unknown as Range;\n\n    // Ensure that results are Text nodes\n    if (isTextNode(startContainer) && isTextNode(endContainer)) {\n      const startTextNode = startContainer;\n      const endTextNode = endContainer;\n\n      // If no content's actually been selected\n      if (startTextNode === endTextNode && range.endOffset === range.startOffset) return results;\n\n      // Convert to absolute offsets in the element\n      const offsets = this.getAbsoluteOffsets(startContainer, range.startOffset, endContainer, range.endOffset);\n\n      // Remove native selection\n      selection.removeAllRanges();\n\n      if (offsets.startOffset && offsets.endOffset) {\n        const length = offsets.endOffset - offsets.startOffset;\n\n        // Check for minimum / maximum\n        const { startOffset, endOffset } = offsets;\n        if ((this.minimum && !(length >= this.minimum)) || (this.maximum && !(length <= this.maximum))) {\n          return results;\n        }\n\n        // Check for overlap\n        if (!this.overlap) {\n          const highlights = this.getData();\n          if (\n            highlights.some(\n              (highlight) =>\n                highlight.startOffset &&\n                highlight.endOffset &&\n                ((startOffset > highlight.startOffset && startOffset < highlight.endOffset) ||\n                  (endOffset > highlight.startOffset && endOffset < highlight.endOffset)),\n            )\n          ) {\n            return results;\n          }\n        }\n      }\n\n      if (isValidOffset(offsets)) {\n        this.highlightRange(offsets.startOffset, offsets.endOffset);\n      }\n\n      return this.getData();\n    }\n\n    return results;\n  }\n\n  /**\n   * Highlights a range of text determined by start and end offsets\n   *\n   * @param {number} startOffset - absolute offset in the element container\n   * @param {number} endOffset - absolute offset in the element container\n   * @returns {DataProps[]}\n   * @memberof Mrkr\n   */\n  highlightRange(startOffset: number, endOffset: number): DataProps[] {\n    const results: DataProps[] = [];\n\n    if (!this.element) {\n      console.error(new Error('Container element not defined for highlighter.'));\n      return results;\n    }\n\n    const textNodes = textNodesUnder(this.element);\n\n    let currentIndex = 0;\n    let startFound = false;\n\n    textNodes.some((textNode) => {\n      if (!textNode.textContent) return false;\n\n      const newCurrentIndex = currentIndex + textNode.textContent.length;\n      if (startOffset >= currentIndex && startOffset < newCurrentIndex) {\n        const newNodes = this.highlightNode(textNode.textContent, startOffset - currentIndex, endOffset - currentIndex);\n        textNode.replaceWith(...newNodes);\n\n        // Start collecting text nodes in between\n        startFound = true;\n      }\n\n      if (endOffset >= currentIndex && endOffset < newCurrentIndex) {\n        const newNodes = this.highlightNode(textNode.textContent, 0, endOffset - currentIndex);\n        textNode.replaceWith(...newNodes);\n\n        // End the loop\n        return true;\n      }\n      if (startFound) {\n        const newNodes = this.highlightNode(textNode.textContent, 0, textNode.textContent.length);\n        textNode.replaceWith(...newNodes);\n      }\n\n      currentIndex = newCurrentIndex;\n      return false;\n    });\n\n    return this.getData();\n  }\n\n  getSelectionEnabled(): boolean {\n    return this.selectionEnabled;\n  }\n\n  toggleSelection(isEnabled: boolean): void {\n    this.selectionEnabled = typeof isEnabled === 'undefined' ? !this.selectionEnabled : isEnabled;\n  }\n\n  enableSelection(): void {\n    this.selectionEnabled = true;\n  }\n\n  disableSelection(): void {\n    this.selectionEnabled = false;\n  }\n}\n"],"file":"Mrkr.js"}