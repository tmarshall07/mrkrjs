{"version":3,"file":"mrkrjs.min.js","sources":["../src/Mrkr.ts"],"sourcesContent":["type OffsetProps = {\n  startOffset?: number;\n  endOffset?: number;\n};\n\ntype DataProps = OffsetProps & {\n  text: string;\n  nodes: Text[];\n};\n\n// Type guard for Text nodes\nfunction isTextNode(node: Node): node is Text {\n  return (node as Text).nodeType === 3;\n}\n\n// Type guard for offset\nfunction isValidOffset(offset?: OffsetProps): offset is { startOffset: number; endOffset: number } {\n  return !!(offset && typeof offset.startOffset === 'number' && typeof offset.endOffset === 'number');\n}\n\n/**\n * Gets an array of text nodes under the passed node\n *\n * @param {HTMLElement} node\n * @returns {[HTMLElement]} - array of text nodes\n */\nconst textNodesUnder = (node: any): Text[] => {\n  let all: Text[] = [];\n\n  // eslint-disable-next-line no-param-reassign\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    if (isTextNode(node)) all.push(node);\n    else all = all.concat(textNodesUnder(node));\n  }\n  return all;\n};\n\ninterface Props {\n  element?: HTMLElement;\n  className?: string;\n  minimum?: number;\n  maximum?: number;\n  overlap?: boolean;\n  onSelection?: (e: PointerEvent, data: DataProps[]) => void;\n}\n\ninterface Range {\n  startContainer: ChildNode;\n  endContainer: ChildNode;\n  startOffset: number;\n  endOffset: number;\n}\n\nexport default class Mrkr {\n  element: HTMLElement;\n\n  highlightClass: string;\n\n  maximum?: number;\n\n  minimum?: number;\n\n  overlap?: boolean;\n\n  onSelection?: (e: PointerEvent, data: DataProps[]) => void;\n\n  private selectionEnabled: boolean;\n\n  constructor(props: Props = {}) {\n    const {\n      element = document.body,\n      className = 'highlight',\n      onSelection,\n      maximum = undefined,\n      minimum = undefined,\n      overlap = true,\n    } = props;\n\n    this.element = element;\n    this.highlightClass = className;\n    this.selectionEnabled = false;\n    this.maximum = maximum;\n    this.minimum = minimum;\n    this.overlap = overlap;\n    this.onSelection = onSelection;\n\n    this.handlePointerUp = this.handlePointerUp.bind(this);\n\n    this.setElement(element);\n  }\n\n  /**\n   * Callback run on pointerup\n   *\n   * @private\n   * @param {PointerEvent} event\n   * @memberof Mrkr\n   */\n  private handlePointerUp(event: PointerEvent) {\n    if (this.selectionEnabled) {\n      const results = this.highlight();\n\n      if (this.onSelection) this.onSelection(event, results);\n    }\n  }\n\n  /**\n   * Gets all nodes that have the current className\n   *\n   * @private\n   * @returns {HTMLElement[]}\n   * @memberof Mrkr\n   */\n  private getHighlightedNodes(className?: string): HTMLElement[] {\n    if (!this.element) return [];\n\n    return Array.from(this.element.querySelectorAll(`.${className || this.highlightClass}`));\n  }\n\n  /**\n   * Creates a set of highlighted and non-highlighted nodes to replace the passed text content\n   *\n   * @private\n   * @param {(string | null)} [text='']\n   * @param {number} startOffset\n   * @param {number} endOffset\n   * @returns {ChildNode[]}\n   * @memberof Mrkr\n   */\n  private highlightNode(text: string | null = '', startOffset: number, endOffset: number): ChildNode[] {\n    if (!text) return [];\n\n    const highlightedText = text.substring(startOffset, endOffset);\n\n    if (highlightedText.length > 0) {\n      const highlightedSpanNode = document.createElement('SPAN');\n      highlightedSpanNode.classList.add(this.highlightClass);\n\n      const startTextNode = document.createTextNode(text.substring(0, startOffset));\n      const highlightedTextNode = document.createTextNode(highlightedText);\n      const endTextNode = document.createTextNode(text.substring(endOffset));\n\n      highlightedSpanNode.appendChild(highlightedTextNode);\n\n      const newNodes = [];\n      if (startTextNode.textContent) newNodes.push(startTextNode);\n      newNodes.push(highlightedSpanNode);\n      if (endTextNode.textContent) newNodes.push(endTextNode);\n\n      return newNodes;\n    }\n\n    return [document.createTextNode(text)];\n  }\n\n  /**\n   * Converts relative range offset data to absolute offsets\n   *\n   * @private\n   * @memberof Mrkr\n   */\n  private getAbsoluteOffsets = (\n    startContainer: Text,\n    startOffset: number,\n    endContainer: Text,\n    endOffset: number,\n  ): OffsetProps => {\n    const textNodes = textNodesUnder(this.element);\n    let currentIndex = 0;\n    let absoluteStartOffset;\n    let absoluteEndOffset;\n\n    textNodes.some((textNode) => {\n      if (!textNode?.textContent) return false;\n\n      if (textNode === startContainer) {\n        absoluteStartOffset = currentIndex + startOffset;\n      }\n\n      if (textNode === endContainer) {\n        absoluteEndOffset = currentIndex + endOffset;\n        return true;\n      }\n\n      currentIndex += textNode.textContent.length;\n      return false;\n    });\n\n    if (absoluteStartOffset && absoluteEndOffset) {\n      return { startOffset: absoluteStartOffset, endOffset: absoluteEndOffset };\n    }\n\n    return {};\n  };\n\n  /**\n   * Adds the event listener for pointerup\n   *\n   * @memberof Mrkr\n   */\n  private register(): void {\n    this.element.addEventListener('pointerup', this.handlePointerUp);\n  }\n\n  /**\n   * Removes the event listener for pointerup\n   *\n   * @memberof Mrkr\n   */\n  private unregister(): void {\n    this.element.removeEventListener('pointerup', this.handlePointerUp);\n  }\n\n  /**\n   * Sets the current classname\n   *\n   * @param {string} className\n   * @memberof Mrkr\n   */\n  setClassName(className: string): void {\n    this.highlightClass = className;\n  }\n\n  /**\n   * Searches the container element for any highlighted nodes\n   * according to the current className\n   *\n   * @param {string} [className] - optional classname, otherwise will check for this.highlightClass\n   * @returns {DataProps[]}\n   * @memberof Mrkr\n   */\n  getData(className?: string): DataProps[] {\n    if (!this.element) return [];\n\n    const textNodes = textNodesUnder(this.element);\n    const highlightedTextNodes = this.getHighlightedNodes(className).reduce(\n      (arr: Text[], current) => [...arr, ...textNodesUnder(current)],\n      [],\n    );\n\n    let currentIndex = 0;\n\n    let startFound = false;\n\n    const data: DataProps[] = [];\n\n    textNodes.some((textNode, i) => {\n      if (!textNode.textContent) return false;\n\n      const highlightedTextNode = highlightedTextNodes.find((node) => node === textNode);\n\n      if (highlightedTextNode) {\n        if (!startFound) {\n          data.push({\n            startOffset: currentIndex,\n            text: textNode.textContent,\n            nodes: [highlightedTextNode],\n          });\n\n          startFound = true;\n        } else {\n          data[data.length - 1].text += textNode.textContent;\n          data[data.length - 1].nodes.push(highlightedTextNode);\n        }\n\n        // If this node is also the last node\n        if (i === textNodes.length - 1) {\n          data[data.length - 1].endOffset = currentIndex + textNode.textContent.length;\n        }\n      } else if (startFound) {\n        data[data.length - 1].endOffset = currentIndex;\n        startFound = false;\n      }\n\n      currentIndex += textNode.textContent.length;\n\n      return false;\n    });\n\n    return data;\n  }\n\n  /**\n   * Sets the current container element\n   *\n   * @param {HTMLElement} element\n   * @memberof Mrkr\n   */\n  setElement(element: HTMLElement): void {\n    this.unregister();\n    this.element = element;\n    this.register();\n  }\n\n  /**\n   * Clears all or part of the highlighted text blocks\n   *\n   * @param {OffsetProps[]} [offsetTargets] - optional array of offsets to target and remove\n   * @returns {void}\n   * @memberof Mrkr\n   */\n  clear(offsetTargets?: OffsetProps[]): void {\n    if (!this.element) return;\n\n    // Guard against bad offset inputs\n    const offsets = offsetTargets?.filter((o) => isValidOffset(o));\n\n    const highlightedNodes = this.getHighlightedNodes();\n    const textNodes = textNodesUnder(this.element);\n\n    // If offsets array not included, clear all\n    if (!offsets) {\n      highlightedNodes.forEach((highlightedNode) => {\n        highlightedNode.replaceWith(...Array.from(highlightedNode.childNodes));\n      });\n    } else {\n      // Clear all highlighted text that falls between the offsets in the passed offsets array\n      let currentIndex = 0;\n\n      // Clear any text nodes that fall inside any of the offset ranges passed\n      textNodes.some((textNode) => {\n        if (\n          offsets.find(\n            (offset) => isValidOffset(offset) && currentIndex >= offset.startOffset && currentIndex <= offset.endOffset,\n          )\n        ) {\n          const highlightedNode = highlightedNodes.find(\n            (node) => !!Array.from(node.childNodes).find((n) => n === textNode),\n          );\n          if (highlightedNode) {\n            highlightedNode.replaceWith(...Array.from(highlightedNode.childNodes));\n          }\n        }\n\n        // Can stop searching\n        const ends = offsets.map((offset) => offset.endOffset).filter((n) => typeof n === 'number') as number[];\n        if (currentIndex > Math.max(...ends)) {\n          return true;\n        }\n\n        currentIndex += textNode.textContent?.length || 0;\n        return false;\n      });\n    }\n  }\n\n  highlight(): DataProps[] {\n    const selection = window.getSelection();\n    const results: DataProps[] = [];\n\n    // If there's no selection object\n    if (!selection) return results;\n\n    // Container element must be defined\n    if (!this.element) {\n      console.error(new Error('Container element not defined for highlighter.'));\n      return results;\n    }\n\n    const range = selection.getRangeAt(0);\n\n    const { startContainer, endContainer } = range as unknown as Range;\n\n    // Ensure that results are Text nodes\n    if (isTextNode(startContainer) && isTextNode(endContainer)) {\n      const startTextNode = startContainer;\n      const endTextNode = endContainer;\n\n      // If no content's actually been selected\n      if (startTextNode === endTextNode && range.endOffset === range.startOffset) return results;\n\n      // Convert to absolute offsets in the element\n      const offsets = this.getAbsoluteOffsets(startContainer, range.startOffset, endContainer, range.endOffset);\n\n      // Remove native selection\n      selection.removeAllRanges();\n\n      if (offsets.startOffset && offsets.endOffset) {\n        const length = offsets.endOffset - offsets.startOffset;\n\n        // Check for minimum / maximum\n        const { startOffset, endOffset } = offsets;\n        if ((this.minimum && !(length >= this.minimum)) || (this.maximum && !(length <= this.maximum))) {\n          return results;\n        }\n\n        // Check for overlap\n        if (!this.overlap) {\n          const highlights = this.getData();\n          if (\n            highlights.some(\n              (highlight) =>\n                highlight.startOffset &&\n                highlight.endOffset &&\n                ((startOffset > highlight.startOffset && startOffset < highlight.endOffset) ||\n                  (endOffset > highlight.startOffset && endOffset < highlight.endOffset)),\n            )\n          ) {\n            return results;\n          }\n        }\n      }\n\n      if (isValidOffset(offsets)) {\n        this.highlightRange(offsets.startOffset, offsets.endOffset);\n      }\n\n      return this.getData();\n    }\n\n    return results;\n  }\n\n  /**\n   * Highlights a range of text determined by start and end offsets\n   *\n   * @param {number} startOffset - absolute offset in the element container\n   * @param {number} endOffset - absolute offset in the element container\n   * @returns {DataProps[]}\n   * @memberof Mrkr\n   */\n  highlightRange(startOffset: number, endOffset: number): DataProps[] {\n    const results: DataProps[] = [];\n\n    if (!this.element) {\n      console.error(new Error('Container element not defined for highlighter.'));\n      return results;\n    }\n\n    const textNodes = textNodesUnder(this.element);\n\n    let currentIndex = 0;\n    let startFound = false;\n\n    textNodes.some((textNode) => {\n      if (!textNode.textContent) return false;\n\n      const newCurrentIndex = currentIndex + textNode.textContent.length;\n      if (startOffset >= currentIndex && startOffset < newCurrentIndex) {\n        const newNodes = this.highlightNode(textNode.textContent, startOffset - currentIndex, endOffset - currentIndex);\n        textNode.replaceWith(...newNodes);\n\n        // Start collecting text nodes in between\n        startFound = true;\n      }\n\n      if (endOffset >= currentIndex && endOffset < newCurrentIndex) {\n        const newNodes = this.highlightNode(textNode.textContent, 0, endOffset - currentIndex);\n        textNode.replaceWith(...newNodes);\n\n        // End the loop\n        return true;\n      }\n      if (startFound) {\n        const newNodes = this.highlightNode(textNode.textContent, 0, textNode.textContent.length);\n        textNode.replaceWith(...newNodes);\n      }\n\n      currentIndex = newCurrentIndex;\n      return false;\n    });\n\n    return this.getData();\n  }\n\n  getSelectionEnabled(): boolean {\n    return this.selectionEnabled;\n  }\n\n  toggleSelection(isEnabled: boolean): void {\n    this.selectionEnabled = typeof isEnabled === 'undefined' ? !this.selectionEnabled : isEnabled;\n  }\n\n  enableSelection(): void {\n    this.selectionEnabled = true;\n  }\n\n  disableSelection(): void {\n    this.selectionEnabled = false;\n  }\n}\n"],"names":["isTextNode","node","nodeType","isValidOffset","offset","startOffset","endOffset","textNodesUnder","all","firstChild","nextSibling","push","concat","Mrkr","props","_this","this","getAbsoluteOffsets","startContainer","endContainer","absoluteStartOffset","absoluteEndOffset","textNodes","element","currentIndex","some","textNode","textContent","length","_a","document","body","_b","className","onSelection","_c","maximum","undefined","_d","minimum","_e","overlap","highlightClass","selectionEnabled","handlePointerUp","bind","setElement","prototype","event","results","highlight","getHighlightedNodes","Array","from","querySelectorAll","highlightNode","text","highlightedText","substring","highlightedSpanNode","createElement","classList","add","startTextNode","createTextNode","highlightedTextNode","endTextNode","appendChild","newNodes","register","addEventListener","unregister","removeEventListener","setClassName","getData","highlightedTextNodes","reduce","arr","current","__spreadArray","startFound","data","i","find","nodes","clear","offsetTargets","offsets","filter","o","highlightedNodes","currentIndex_1","highlightedNode","childNodes","n","replaceWith","apply","ends","map","Math","max","forEach","selection","window","getSelection","console","error","Error","range","getRangeAt","removeAllRanges","length_1","startOffset_1","endOffset_1","highlightRange","newCurrentIndex","getSelectionEnabled","toggleSelection","isEnabled","enableSelection","disableSelection"],"mappings":"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"}